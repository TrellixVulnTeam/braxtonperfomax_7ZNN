import { ChangeDetectorRef, ElementRef, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges } from '@angular/core';
import { GridsterComponentInterface } from './gridster.interface';
import { GridsterCompact } from './gridsterCompact.service';
import { GridsterConfig } from './gridsterConfig.interface';
import { GridsterConfigS } from './gridsterConfigS.interface';
import { GridsterEmptyCell } from './gridsterEmptyCell.service';
import { GridsterItem, GridsterItemComponentInterface } from './gridsterItem.interface';
import { GridsterRenderer } from './gridsterRenderer.service';
import * as ɵngcc0 from '@angular/core';
export declare class GridsterComponent implements OnInit, OnChanges, OnDestroy, GridsterComponentInterface {
    renderer: Renderer2;
    cdRef: ChangeDetectorRef;
    zone: NgZone;
    options: GridsterConfig;
    calculateLayoutDebounce: () => void;
    movingItem: GridsterItem | null;
    previewStyle: () => void;
    el: HTMLElement;
    $options: GridsterConfigS;
    mobile: boolean;
    curWidth: number;
    curHeight: number;
    grid: GridsterItemComponentInterface[];
    columns: number;
    rows: number;
    curColWidth: number;
    curRowHeight: number;
    gridColumns: never[];
    gridRows: never[];
    windowResize: (() => void) | null;
    dragInProgress: boolean;
    emptyCell: GridsterEmptyCell;
    compact: GridsterCompact;
    gridRenderer: GridsterRenderer;
    constructor(el: ElementRef, renderer: Renderer2, cdRef: ChangeDetectorRef, zone: NgZone);
    static checkCollisionTwoItemsForSwaping(item: GridsterItem, item2: GridsterItem): boolean;
    checkCollisionTwoItems(item: GridsterItem, item2: GridsterItem): boolean;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    resize(): void;
    setOptions(): void;
    optionsChanged(): void;
    ngOnDestroy(): void;
    onResize(): void;
    checkIfToResize(): boolean;
    setGridSize(): void;
    setGridDimensions(): void;
    calculateLayout(): void;
    updateGrid(): void;
    addItem(itemComponent: GridsterItemComponentInterface): void;
    removeItem(itemComponent: GridsterItemComponentInterface): void;
    checkCollision(item: GridsterItem): GridsterItemComponentInterface | boolean;
    checkGridCollision(item: GridsterItem): boolean;
    findItemWithItem(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemsWithItem(item: GridsterItem): Array<GridsterItemComponentInterface>;
    autoPositionItem(itemComponent: GridsterItemComponentInterface): void;
    getNextPossiblePosition(newItem: GridsterItem, startingFrom?: {
        y?: number;
        x?: number;
    }): boolean;
    getFirstPossiblePosition(item: GridsterItem): GridsterItem;
    getLastPossiblePosition(item: GridsterItem): GridsterItem;
    pixelsToPositionX(x: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    pixelsToPositionY(y: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    positionXToPixels(x: number): number;
    positionYToPixels(y: number): number;
    getItemComponent(item: GridsterItem): GridsterItemComponentInterface | undefined;
    checkCollisionForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemWithItemForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    private static getNewArrayLength;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<GridsterComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<GridsterComponent, "gridster", never, { "options": "options"; }, {}, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImdyaWRzdGVyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIE5nWm9uZSwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEdyaWRzdGVyQ29tcG9uZW50SW50ZXJmYWNlIH0gZnJvbSAnLi9ncmlkc3Rlci5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBHcmlkc3RlckNvbXBhY3QgfSBmcm9tICcuL2dyaWRzdGVyQ29tcGFjdC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZHN0ZXJDb25maWcgfSBmcm9tICcuL2dyaWRzdGVyQ29uZmlnLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEdyaWRzdGVyQ29uZmlnUyB9IGZyb20gJy4vZ3JpZHN0ZXJDb25maWdTLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IEdyaWRzdGVyRW1wdHlDZWxsIH0gZnJvbSAnLi9ncmlkc3RlckVtcHR5Q2VsbC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR3JpZHN0ZXJJdGVtLCBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2UgfSBmcm9tICcuL2dyaWRzdGVySXRlbS5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBHcmlkc3RlclJlbmRlcmVyIH0gZnJvbSAnLi9ncmlkc3RlclJlbmRlcmVyLnNlcnZpY2UnO1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBHcmlkc3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEdyaWRzdGVyQ29tcG9uZW50SW50ZXJmYWNlIHtcclxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjI7XHJcbiAgICBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWY7XHJcbiAgICB6b25lOiBOZ1pvbmU7XHJcbiAgICBvcHRpb25zOiBHcmlkc3RlckNvbmZpZztcclxuICAgIGNhbGN1bGF0ZUxheW91dERlYm91bmNlOiAoKSA9PiB2b2lkO1xyXG4gICAgbW92aW5nSXRlbTogR3JpZHN0ZXJJdGVtIHwgbnVsbDtcclxuICAgIHByZXZpZXdTdHlsZTogKCkgPT4gdm9pZDtcclxuICAgIGVsOiBIVE1MRWxlbWVudDtcclxuICAgICRvcHRpb25zOiBHcmlkc3RlckNvbmZpZ1M7XHJcbiAgICBtb2JpbGU6IGJvb2xlYW47XHJcbiAgICBjdXJXaWR0aDogbnVtYmVyO1xyXG4gICAgY3VySGVpZ2h0OiBudW1iZXI7XHJcbiAgICBncmlkOiBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2VbXTtcclxuICAgIGNvbHVtbnM6IG51bWJlcjtcclxuICAgIHJvd3M6IG51bWJlcjtcclxuICAgIGN1ckNvbFdpZHRoOiBudW1iZXI7XHJcbiAgICBjdXJSb3dIZWlnaHQ6IG51bWJlcjtcclxuICAgIGdyaWRDb2x1bW5zOiBuZXZlcltdO1xyXG4gICAgZ3JpZFJvd3M6IG5ldmVyW107XHJcbiAgICB3aW5kb3dSZXNpemU6ICgoKSA9PiB2b2lkKSB8IG51bGw7XHJcbiAgICBkcmFnSW5Qcm9ncmVzczogYm9vbGVhbjtcclxuICAgIGVtcHR5Q2VsbDogR3JpZHN0ZXJFbXB0eUNlbGw7XHJcbiAgICBjb21wYWN0OiBHcmlkc3RlckNvbXBhY3Q7XHJcbiAgICBncmlkUmVuZGVyZXI6IEdyaWRzdGVyUmVuZGVyZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLCB6b25lOiBOZ1pvbmUpO1xyXG4gICAgc3RhdGljIGNoZWNrQ29sbGlzaW9uVHdvSXRlbXNGb3JTd2FwaW5nKGl0ZW06IEdyaWRzdGVySXRlbSwgaXRlbTI6IEdyaWRzdGVySXRlbSk6IGJvb2xlYW47XHJcbiAgICBjaGVja0NvbGxpc2lvblR3b0l0ZW1zKGl0ZW06IEdyaWRzdGVySXRlbSwgaXRlbTI6IEdyaWRzdGVySXRlbSk6IGJvb2xlYW47XHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XHJcbiAgICByZXNpemUoKTogdm9pZDtcclxuICAgIHNldE9wdGlvbnMoKTogdm9pZDtcclxuICAgIG9wdGlvbnNDaGFuZ2VkKCk6IHZvaWQ7XHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xyXG4gICAgb25SZXNpemUoKTogdm9pZDtcclxuICAgIGNoZWNrSWZUb1Jlc2l6ZSgpOiBib29sZWFuO1xyXG4gICAgc2V0R3JpZFNpemUoKTogdm9pZDtcclxuICAgIHNldEdyaWREaW1lbnNpb25zKCk6IHZvaWQ7XHJcbiAgICBjYWxjdWxhdGVMYXlvdXQoKTogdm9pZDtcclxuICAgIHVwZGF0ZUdyaWQoKTogdm9pZDtcclxuICAgIGFkZEl0ZW0oaXRlbUNvbXBvbmVudDogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlKTogdm9pZDtcclxuICAgIHJlbW92ZUl0ZW0oaXRlbUNvbXBvbmVudDogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlKTogdm9pZDtcclxuICAgIGNoZWNrQ29sbGlzaW9uKGl0ZW06IEdyaWRzdGVySXRlbSk6IEdyaWRzdGVySXRlbUNvbXBvbmVudEludGVyZmFjZSB8IGJvb2xlYW47XHJcbiAgICBjaGVja0dyaWRDb2xsaXNpb24oaXRlbTogR3JpZHN0ZXJJdGVtKTogYm9vbGVhbjtcclxuICAgIGZpbmRJdGVtV2l0aEl0ZW0oaXRlbTogR3JpZHN0ZXJJdGVtKTogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlIHwgYm9vbGVhbjtcclxuICAgIGZpbmRJdGVtc1dpdGhJdGVtKGl0ZW06IEdyaWRzdGVySXRlbSk6IEFycmF5PEdyaWRzdGVySXRlbUNvbXBvbmVudEludGVyZmFjZT47XHJcbiAgICBhdXRvUG9zaXRpb25JdGVtKGl0ZW1Db21wb25lbnQ6IEdyaWRzdGVySXRlbUNvbXBvbmVudEludGVyZmFjZSk6IHZvaWQ7XHJcbiAgICBnZXROZXh0UG9zc2libGVQb3NpdGlvbihuZXdJdGVtOiBHcmlkc3Rlckl0ZW0sIHN0YXJ0aW5nRnJvbT86IHtcclxuICAgICAgICB5PzogbnVtYmVyO1xyXG4gICAgICAgIHg/OiBudW1iZXI7XHJcbiAgICB9KTogYm9vbGVhbjtcclxuICAgIGdldEZpcnN0UG9zc2libGVQb3NpdGlvbihpdGVtOiBHcmlkc3Rlckl0ZW0pOiBHcmlkc3Rlckl0ZW07XHJcbiAgICBnZXRMYXN0UG9zc2libGVQb3NpdGlvbihpdGVtOiBHcmlkc3Rlckl0ZW0pOiBHcmlkc3Rlckl0ZW07XHJcbiAgICBwaXhlbHNUb1Bvc2l0aW9uWCh4OiBudW1iZXIsIHJvdW5kaW5nTWV0aG9kOiAoeDogbnVtYmVyKSA9PiBudW1iZXIsIG5vTGltaXQ/OiBib29sZWFuKTogbnVtYmVyO1xyXG4gICAgcGl4ZWxzVG9Qb3NpdGlvblkoeTogbnVtYmVyLCByb3VuZGluZ01ldGhvZDogKHg6IG51bWJlcikgPT4gbnVtYmVyLCBub0xpbWl0PzogYm9vbGVhbik6IG51bWJlcjtcclxuICAgIHBvc2l0aW9uWFRvUGl4ZWxzKHg6IG51bWJlcik6IG51bWJlcjtcclxuICAgIHBvc2l0aW9uWVRvUGl4ZWxzKHk6IG51bWJlcik6IG51bWJlcjtcclxuICAgIGdldEl0ZW1Db21wb25lbnQoaXRlbTogR3JpZHN0ZXJJdGVtKTogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlIHwgdW5kZWZpbmVkO1xyXG4gICAgY2hlY2tDb2xsaXNpb25Gb3JTd2FwaW5nKGl0ZW06IEdyaWRzdGVySXRlbSk6IEdyaWRzdGVySXRlbUNvbXBvbmVudEludGVyZmFjZSB8IGJvb2xlYW47XHJcbiAgICBmaW5kSXRlbVdpdGhJdGVtRm9yU3dhcGluZyhpdGVtOiBHcmlkc3Rlckl0ZW0pOiBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2UgfCBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TmV3QXJyYXlMZW5ndGg7XHJcbn1cclxuIl19